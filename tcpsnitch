#!/usr/bin/env bash
set -o errexit
set -o nounset
# set -o xtrace

VERSION=0.1.0
VERSION_STR="tcpsnitch version ${VERSION}"
MAX_VERBOSITY=1

# Option default values
OPT_B=4096
OPT_D=""
OPT_F=2
OPT_L=0
OPT_U=0
OPT_V=0

usage() {
        echo "Usage: tcpsnitch [-hv] [ -b <bytes> ] [ -d <dir>] [ -f <lvl> ]"
        echo "                 [ -u <ms> ] [ -l <lvl> ] [ --version ]"
        echo ""
        echo "[command]: command to spy on."
        echo "-h: show this help text."
        echo "-b <bytes>: dump tcp_info max once every <bytes> bytes (defaults"\
             "to 4096)."
        echo "-d <dir>: dir to save traces (defaults to random dir in /tmp)."
        echo "-f <lvl>: logs to file verbosity (0 to 5, defaults to 2)."
        echo "-l <lvl>: logs to stderr verbosity (0 to 5, defaults to 0)."  
        echo "-u <micro_seconds>: dump tcp_info max once every <ms> micro"\
             "seconds (defaults to 0)."
        echo "-v: verbose output."  
        echo "--version: print tcpsnitch version." 
}

is_integer() {
        [[ "$1" =~ ^[0-9]+$ ]]
}

assert_int() {
        if ! is_integer "$1"; then
                echo "Error: Invalid argument: $1. $2"
                exit 1
        fi
}

# Parse options
while getopts ":hvb:d:f:l:u:-:" opt; do
        case $opt in
                -) # Trick to parse long options with getopts.
                        case "$OPTARG" in
                                version)
                                        echo ${VERSION_STR}
                                        exit 0
                                        ;;
                        esac
                        ;;
                h)
                        usage
                        exit 0
                        ;;
                b)
                        assert_int "$OPTARG" "-b accepts a non-neg integer." 
                        OPT_B=$OPTARG
                        ;;
                d)
                        if [[ ! -d "$OPTARG" ]] ; then
                                echo "Error: Invalid argument: $OPTARG. -d "\
                                  "accepts a valid directory."  
                                exit 1
                        fi
                        OPT_D=$OPTARG
                        ;;
                f)
                        assert_int "$OPTARG" "-f accepts a non-neg integer." 
                        OPT_F=$OPTARG
                        ;;
                l)
                        assert_int "$OPTARG" "-l accepts a non-neg integer." 
                        OPT_L=$OPTARG
                        ;;
                u)
                        assert_int "$OPTARG" "-u accepts a non-neg integer." 
                        OPT_U=$OPTARG
                        ;;
                v)
                        OPT_V=$((OPT_V+1))
                        ;;
               \?)     
                        echo "Error: Invalid option (see -h for usage)."
                        usage
                        exit 1
                        ;;
        esac
done

# Consume option args
shift $((OPTIND - 1))

# Verify number of arguments
if [[ $# -lt 1 ]]; then
        echo "Error: Illegal number of arguments."
        usage
        exit 1
fi

# Test command validity
command=$1
if [ ${command:0:2} = "./" -o ${command:0:1} = "/" ]; then # $command is a path
  if ! [[ -x $command ]]; then
    echo "Error: $command is not executable."
    exit 1
  fi
else
  if ! which $command > /dev/null; then
    echo "Error: $command is not in \$PATH."
    exit 1
  fi
fi

if [[ ! $(which $command) ]] && [[ ! -x $command ]]; then
  echo "trouble"
  exit 1
fi


# Create temp dir if option -d not used
if [[ -z "$OPT_D" ]]; then
        OPT_D=$(mktemp -d)
        chmod 555 "$OPT_D"
fi

# Save network config
NET_CONFIG_PATH="$OPT_D/sysctl_net.txt"
if [[ ! -e "$NET_CONFIG_PATH" ]]; then
        sysctl net > "$NET_CONFIG_PATH" 2> /dev/null
fi

# Save os config
OS_CONFIG_PATH="$OPT_D/uname.txt"
if [[ ! -e "$OS_CONFIG_PATH" ]]; then
        uname -a > "$OS_CONFIG_PATH"
fi

TCPSNITCH_BYTES_IVAL=$OPT_B \
TCPSNITCH_DIR="$OPT_D" \
TCPSNITCH_FILE_LOG_LVL="$OPT_F" \
TCPSNITCH_STDERR_LOG_LVL="$OPT_L" \
TCPSNITCH_MICROS_IVAL=$OPT_U \
TCPSNITCH_VERBOSITY=$OPT_V \
LD_PRELOAD=/usr/local/lib/libtcpsnitch.so $@ 3>&1 4>&2 1>/dev/null 2>&1

>&2 echo "tcpsnitch data saved in $OPT_D"
