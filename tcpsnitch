#!/usr/bin/env bash
set -o errexit
set -o nounset
# set -o xtrace

NAME="tcpsnitch"
VERSION=0.1.0
VERSION_STR="${NAME} version ${VERSION}"
UNAME_FILE="uname.txt"
SYSCTL_FILE="sysctl_net.txt"

# Option default values
OPT_B=4096
OPT_D=""
OPT_F=2
OPT_L=0
OPT_U=0
OPT_V=0

usage() {
        echo "Usage: tcpsnitch [-hv] [ -b <bytes> ] [ -d <dir>] [ -f <lvl> ]"
        echo "                 [ -u <ms> ] [ -l <lvl> ] [ --version ]"
        echo ""
        echo "[command]: command to spy on."
        echo "-b <bytes>: dump tcp_info max once every <bytes> bytes (defaults"\
             "to 4096)."
        echo "-d <dir>: dir to save traces (defaults to random dir in /tmp)."
        echo "-f <lvl>: logs to file verbosity (0 to 5, defaults to 2)."
        echo "-h: show this help text."
        echo "-l <lvl>: logs to stderr verbosity (0 to 5, defaults to 0)."  
        echo "-u <micro_seconds>: dump tcp_info max once every <ms> micro"\
             "seconds (defaults to 0)."
        echo "-v: verbose output."  
        echo "--version: print tcpsnitch version." 
}

is_integer() {
        [[ "$1" =~ ^[0-9]+$ ]]
}

assert_int() {
        error_msg=$2
        if ! is_integer "$1"; then
                error "$error_msg"
                exit 1
        fi
}

error() {
        msg=$1
        echo "${NAME}: ${msg}."
        echo "Try '${NAME} -h' for more information."
}

# Parse options
while getopts ":hvb:d:f:l:u:-:" opt; do
        case $opt in
                -) # Trick to parse long options with getopts.
                        case "$OPTARG" in
                                version)
                                        echo ${VERSION_STR}
                                        exit 0
                                        ;;
                        esac
                        ;;
                h)
                        usage
                        exit 0
                        ;;
                b)
                        assert_int "$OPTARG" "invalid -b argument: '$OPTARG'" 
                        OPT_B=$OPTARG
                        ;;
                d)
                        if [[ ! -d "$OPTARG" ]] ; then
                                error "invalid -d argument: '$OPTARG'"
                                exit 1
                        fi
                        OPT_D=$OPTARG
                        ;;
                f)
                        assert_int "$OPTARG" "invalid -f argument: '$OPTARG'" 
                        OPT_F=$OPTARG
                        ;;
                l)
                        assert_int "$OPTARG" "invalid -l argument: '$OPTARG'" 
                        OPT_L=$OPTARG
                        ;;
                u)
                        assert_int "$OPTARG" "invalid -u argument: '$OPTARG'" 
                        OPT_U=$OPTARG
                        ;;
                v)
                        OPT_V=$((OPT_V+1))
                        ;;
               \?)     
                        error "invalid option"
                        exit 1
                        ;;
        esac
done

# Consume option args
shift $((OPTIND - 1))

# Verify number of arguments
if [[ $# -lt 1 ]]; then
        error "too few arguments"
        exit 1
fi

# Test command is executable/in path
command=$1
if [ ${command:0:2} = "./" -o ${command:0:1} = "/" ]; then # $command is a path
        if ! [[ -x $command ]]; then
                error "invalid command: '$command' is not executable" 
                exit 1
        fi
else
        if ! which $command > /dev/null; then
                error "invalid argument: '$command' is not in \$PATH"
                exit 1
        fi
fi

# Create temp dir if option -d not used
if [[ -z "$OPT_D" ]]; then
        OPT_D=$(mktemp -d)
        chmod 555 "$OPT_D"
fi

# Save network config
NET_CONFIG_PATH="${OPT_D}/${SYSCTL_FILE}"
if [[ ! -e "$NET_CONFIG_PATH" ]]; then
        sysctl net > "$NET_CONFIG_PATH" 2> /dev/null
fi

# Save os config
OS_CONFIG_PATH="${OPT_D}/${UNAME_FILE}"
if [[ ! -e "$OS_CONFIG_PATH" ]]; then
        uname -a > "$OS_CONFIG_PATH"
fi

TCPSNITCH_BYTES_IVAL=$OPT_B \
TCPSNITCH_DIR="$OPT_D" \
TCPSNITCH_FILE_LOG_LVL="$OPT_F" \
TCPSNITCH_STDERR_LOG_LVL="$OPT_L" \
TCPSNITCH_MICROS_IVAL=$OPT_U \
TCPSNITCH_VERBOSITY=$OPT_V \
LD_PRELOAD=/usr/local/lib/libtcpsnitch.so $@ 3>&1 4>&2 1>/dev/null 2>&1

echo "tcpsnitch data saved in $OPT_D"
