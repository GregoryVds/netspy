#!/usr/bin/env bash
set -o nounset
# set -o xtrace

NAME="tcpsnitch"
VERSION=1.0
VERSION_STR="${NAME} version ${VERSION}"

# Option default values
OPT_B=0
OPT_C=0
OPT_D=""
OPT_F=2
OPT_L=2
OPT_P=0
OPT_U=0
OPT_T=1000
OPT_V=0

usage() {
        echo "Usage: tcpsnitch [-chpv] [ -b <bytes> ] [ -d <dir>]" 
        echo "                 [ -e <events> ] [ -f <lvl> ] [ -l <lvl> ]"
        echo "                 [ -t <msec> ] [ -u <usec> ] [ --version ]"
        echo "                 command <args>"
        echo ""
        echo "command     command to spy on."
        echo "<args>      args to command."
        echo "-b <bytes>  dump tcp_info every <bytes> (0 means NO dump, def 0)."
        echo "-c          activate capture of pcap traces."
        echo "-d <dir>    dir to save traces (defaults to random dir in /tmp)."
        echo "-e <events> dump to JSON file every <events> (def. 1024)."
        echo "-f <lvl>    verbosity of logs to file (0 to 5, defaults to 2)."
        echo "-h          show this help text."
        echo "-l <lvl>    verbosity of logs to stderr (0 to 5, defaults to 2)."  
        echo "-p          activate pretty print of JSON traces."
        echo "-t <msec>   dump to JSON file every <msec> (def. 1000)."
        echo "-u <usec>   dump tcp_info every <usec> (0 means NO dump, def 0)."
        echo "-v          activate verbose output."  
        echo "--version   print tcpsnitch version." 
}

is_integer() {
        [[ "$1" =~ ^[0-9]+$ ]]
}

assert_int() {
        error_msg=$2
        if ! is_integer "$1"; then
                error "$error_msg"
                exit 1
        fi
}

error() {
        msg=$1
        echo "${NAME}: ${msg}."
        echo "Try '${NAME} -h' for more information."
}

# Parse options
while getopts ":chpvb:d:e:f:i:l:u:t:-:" opt; do
        case $opt in
                -) # Trick to parse long options with getopts.
                        case "$OPTARG" in
                                version)
                                        echo ${VERSION_STR}
                                        exit 0
                                        ;;
                        esac
                        ;;
                h)
                        usage
                        exit 0
                        ;;
                b)
                        assert_int "$OPTARG" "invalid -b argument: '$OPTARG'" 
                        OPT_B=$OPTARG
                        ;;
                c)
                        OPT_C=1;
                        ;;
                d)
                        if [[ ! -d "$OPTARG" ]] ; then
                                error "invalid -d argument: '$OPTARG'"
                                exit 1
                        fi
                        OPT_D=$OPTARG
                        ;;
                f)
                        assert_int "$OPTARG" "invalid -f argument: '$OPTARG'" 
                        OPT_F=$OPTARG
                        ;;
                i)
                        if ! ip link show $OPTARG >/dev/null ; then
                                error "invalid -i argument: '$OPTARG'"
                                exit 1
                        fi
                        OPT_I=$OPTARG
                        ;;
                l)
                        assert_int "$OPTARG" "invalid -l argument: '$OPTARG'" 
                        OPT_L=$OPTARG
                        ;;
                p)
                        OPT_P=1
                        ;;
                u)
                        assert_int "$OPTARG" "invalid -u argument: '$OPTARG'" 
                        OPT_U=$OPTARG
                        ;;
                t)
                        assert_int "$OPTARG" "invalid -t argument: '$OPTARG'"
                        OPT_T=$OPTARG
                        ;;
                v)
                        OPT_V=$((OPT_V+1))
                        ;;
               \?)     
                        error "invalid option"
                        exit 1
                        ;;
        esac
done

# Consume option args
shift $((OPTIND - 1))

# Verify number of arguments
if [[ $# -lt 1 ]]; then
        error "too few arguments"
        exit 1
fi
	
# Test command is executable/in path
command=$1
if [ ${command:0:2} = "./" -o ${command:0:1} = "/" ]; then # $command is a path
	if ! [[ -x $command ]]; then
		error "invalid command: '$command' is not executable" 
		exit 1
	fi
else
	if ! which $command > /dev/null; then
		error "invalid argument: '$command' is not in \$PATH"
		exit 1
	fi
fi

# Create temp dir if option -d not used
if [[ -z "$OPT_D" ]]; then
	OPT_D=$(mktemp -d)
	chmod 777 "$OPT_D"
fi

####################
# Meta information #
####################

META_DIR="$OPT_D/meta"
mkdir $META_DIR

# app
echo "$1" > "$META_DIR/app"
# cmd
echo "$@" > "$META_DIR/cmd"
# TODO: connectivity
echo "wifi" > "$META_DIR/wifi"
# kernel
uname -r > "$META_DIR/kernel"
# machine
uname -m > "$META_DIR/machine"
# net
sysctl net > "$META_DIR/net" 2>/dev/null
# os
uname -s > "$META_DIR/os"

##############
# Launch CMD #
##############

LIB_32="/usr/local/lib/i386-linux-gnu/libtcpsnitch.so.${VERSION}"
LIB_64="/usr/local/lib/x86_64-linux-gnu/libtcpsnitch.so.${VERSION}"
UNWANTED_ERRORS="wrong ELF class: ELFCLASS32|wrong ELF class: ELFCLASS64"

( \
TCPSNITCH_OPT_B=$OPT_B \
TCPSNITCH_OPT_C=$OPT_C \
TCPSNITCH_OPT_D=$OPT_D \
TCPSNITCH_OPT_F=$OPT_F \
TCPSNITCH_OPT_L=$OPT_L \
TCPSNITCH_OPT_P=$OPT_P \
TCPSNITCH_OPT_T=$OPT_T \
TCPSNITCH_OPT_U=$OPT_U \
TCPSNITCH_OPT_V=$OPT_V \
LD_PRELOAD="${LIB_32} ${LIB_64}" $@ 4>&1 2>&1 3>&2 1>/dev/null | \
grep -E -v "$UNWANTED_ERRORS" \
) 3>&1 1>&2 2>&3

# WHAT JUST HAPPENED?
# First, we have to know that tcpsnitch opens 2 streams to file descriptors 3 
# and 4. These new streams serve as the new stdout/stderr for tcpsnitch. This 
# allows us to distinguish stdout/stderr from tcpsnitch & the traced process. 
#
# Now, we want to perform the following manipulations with these 4 streams:
#       - Discard stdout of the traced process.
#       - Merge stderr of tcpsnitch and the traced process.
#       - Send stdout of tcpsnitch to stdout of traced process.
#       - Filter stderr to remove some errors that are always thrown.
#
# To do this, we start by swapping stderr & stdout:
#       - 4>&1 2>&1: stderr of process+tcpsnitch go to stdout. They merge.
#       - 3>&2: stdout of tcpsnitch goes to stderr.
#       - 1>/devnull: dicard stdout of process.
#
# Now, we filter unwanted errors using "grep -v".
# Finally, we swap back stderr and stdout. Done.

echo "tcpsnitch data saved in $OPT_D"
