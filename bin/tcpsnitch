#!/usr/bin/env bash
set -o nounset
# set -o xtrace

# Name & version
NAME="tcpsnitch"
VERSION=0.1
VERSION_STR="${NAME} version ${VERSION}"

I386_LIB="./lib${NAME}.so.${VERSION}-i386"
AMD64_LIB="./lib${NAME}.so.${VERSION}-x86_64"
ARM_LIB="./lib${NAME}.so.${VERSION}-arm"

# Option default values
OPT_A=0
OPT_B=0
OPT_C=0
OPT_D=""
OPT_F=2
OPT_L=2
OPT_P=0
OPT_T=1000
OPT_U=0
OPT_V=0

# Exit on TERM signal
trap "exit 1" TERM
export TOP_PID=$$

error() {
    msg=$1
    echo "${NAME}: ${msg}."
    echo "Try '$0 -h' for more information."
    kill -s TERM $TOP_PID
}

info() {
    msg=$1
    echo "${msg}."
}

usage() {
    echo "Usage: ${NAME} [-achv] [ -b <bytes> ] [ -d <dir>] [ -f <lvl> ]"
    echo "                 [ -k <pkg> ] [ -l <lvl> ] [ -t <msec> ]"
    echo "                 [ -u <usec> ] [ --version ] app <args>"
    echo ""
    echo "app         command/package to spy on."
    echo "<args>      args to command."
    echo "-a          instrument & launch app on connected android device."
    echo "-b <bytes>  dump tcp_info every <bytes> (0 means NO dump, def 0)."
    echo "-c          activate capture of pcap traces."
    echo "-d <dir>    dir to save traces (defaults to random dir in /tmp)."
    echo "-f <lvl>    verbosity of logs to file (0 to 5, defaults to 2)."
    echo "-h          show this help text."
    echo "-k <pkg>    kill instrumented android <pkg> and pull traces."
    echo "-l <lvl>    verbosity of logs to stderr (0 to 5, defaults to 2)."
    echo "-t <msec>   dump to JSON file every <msec> (def. 1000)."
    echo "-u <usec>   dump tcp_info every <usec> (0 means NO dump, def 0)."
    echo "-v          activate verbose output."
    echo "--version   print ${NAME} version."
}

is_integer() {
    [[ "$1" =~ ^[0-9]+$ ]]
}

assert_int() {
    error_msg=$2
    if ! is_integer "$1"; then
        error "$error_msg"
    fi
}

validate_args_number() {
    if [[ $# -lt 1 ]]; then
        error "too few arguments"
    fi
}

validate_executable() {
    cmd=$1
    if [ ${cmd:0:2} = "./" -o ${cmd:0:1} = "/" ]; then # $cmd is a path
        if ! [[ -x "$cmd" ]]; then
            error "invalid cmd: '$cmd' is not executable" 
        fi
    else
        if ! which $cmd > /dev/null; then
            error "invalid argument: '$cmd' is not in \$PATH"
        fi
    fi
}

get_android_package() {
    if [[ $# -ne 1 ]]; then
        error "missing package argument"
    fi

    package_name=$1
    # Check that adb sees exactly 1 device
    if [ $(adb devices | wc -l) -ne 3 ]; then
        error "adb must see exactly 1 device"
    fi

    prefix="package:"
    match=$(echo $(adb shell pm list packages | grep -m 1 -s "$package_name") | tr -d '\r')

    # Check that package exists
    if [ -z "$match" ]; then
        error "invalid argument: package '$package_name' not found"
    fi

    __PACKAGE=${match#${prefix}}
    info "Found Android package: '${__PACKAGE}'"
}

start_android_package() {
    adb shell "monkey -p ${__PACKAGE} -c android.intent.category.LAUNCHER 1 >/dev/null"
    info "Start package '${__PACKAGE}'"
}

kill_android_package() {
    adb shell su -c am force-stop ${__PACKAGE}
}

pull_trace_for_android_package() {
    tracesdir="/data/data/${__PACKAGE}/${NAME}"

    if [[ ! $(adb shell su -c ls ${tracesdir}) ]]; then
        error "no traces for '${__PACKAGE}'"
    fi

    info "Pulling trace from Android device..."

    tmpdir=$(mktemp -d)
    chmod 777 "$tmpdir"
    adb shell su -c ls ${tracesdir} | while read -r line; do
        trace=$(echo $line | tr -d '\r')
        adb shell su -c mv "${tracesdir}/${trace}" "/data/${trace}"
        adb shell su busybox chmod -R 777 "/data/${trace}"
        adb pull "/data/${trace}" "${tmpdir}/${trace}" 2>/dev/null
        adb shell su -c rm -rf "/data/${trace}"
    done

    info "Trace saved in $tmpdir"
}

parse_options() {
    # Parse options
    while getopts ":achpvb:d:f:k:l:u:t:-:" opt; do
        case $opt in
            -) # Trick to parse long options with getopts.
                case "$OPTARG" in
                    version)
                        info $VERSION_STR
                        exit 0
                        ;;
                esac
                ;;
            a)
                OPT_A=1
                ;;
            b)
                assert_int "$OPTARG" "invalid -b argument: '$OPTARG'" 
                OPT_B=$OPTARG
                ;;
            c)
                OPT_C=1;
                ;;
            d)
                if [[ ! -d "$OPTARG" ]] ; then
                    error "invalid -d argument: '$OPTARG'"
                fi
                OPT_D=$OPTARG
                ;;
            f)
                assert_int "$OPTARG" "invalid -f argument: '$OPTARG'" 
                OPT_F=$OPTARG
                ;;
            h)
                usage
                exit 0
                ;;
            k)
                get_android_package $2
                kill_android_package
                pull_trace_for_android_package
                exit 0
                ;;
            l)
                assert_int "$OPTARG" "invalid -l argument: '$OPTARG'" 
                OPT_L=$OPTARG
                ;;
            u)
                assert_int "$OPTARG" "invalid -u argument: '$OPTARG'" 
                OPT_U=$OPTARG
                ;;
            t)
                assert_int "$OPTARG" "invalid -t argument: '$OPTARG'"
                OPT_T=$OPTARG
                ;;
            v)
                OPT_V=$((OPT_V+1))
                ;;
            \?)
                error "invalid option"
                ;;
        esac
    done
}

###################
# Start of script #
###################

cd $(dirname $(realpath $0))

parse_options $@

# Consume option args
shift $((OPTIND - 1))

validate_args_number $@

command=$1

if [ $OPT_A -eq "1" ]; then
    ###########
    # Android #
    ###########

    # Test if Android lib was compiled
    if [[ ! -f ${ARM_LIB} ]]; then
        error "Android lib missing! Reinstall ${NAME} for Android (see README)"
    fi

    # Validate package
    get_android_package $command

    # Kill package if running
    kill_android_package

    # Desactivate Selinux
    adb shell su -c setenforce 0

    # Create logs dir
    OPT_D="/data/data/${__PACKAGE}/${NAME}"
    adb shell su -c rm -rf ${OPT_D}
    adb shell su -c mkdir -m 777 -p ${OPT_D}

    # Write meta data
    meta_dir="$OPT_D/meta"
    adb shell mkdir $meta_dir
    adb shell "echo ${__PACKAGE} > ${meta_dir}/app"
    adb shell "echo ${__PACKAGE} > ${meta_dir}/cmd"
    adb shell "uname -r > ${meta_dir}/kernel"
    adb shell "uname -m > ${meta_dir}/machine"
    adb shell "sysctl net > ${meta_dir}/net 2>/dev/null"
    adb shell "echo android > ${meta_dir}/os"
    adb shell "echo ${VERSION} > ${meta_dir}/version"

    # Upload lib
    BASE_PROP="be.ucl.${NAME}"
    LIBPATH="/data"
    adb shell su -c chmod 777 /data
    adb shell rm -f "${LIBPATH}/${ARM_LIB}"
    info "Uploading ${NAME} library to ${LIBPATH}/${ARM_LIB}"
    adb push ${ARM_LIB} ${LIBPATH} 2>/dev/null

    # Properties are limited to 32 chars includind the NULL byte.
    # With "wrap." being 5 chars, we have 26 chars left the app name.
    adb shell setprop wrap.${__PACKAGE:0:26} LD_PRELOAD="${LIBPATH}/${ARM_LIB}"
    adb shell setprop "$BASE_PROP.opt_b" "$OPT_B"
    adb shell setprop "$BASE_PROP.opt_c" "$OPT_C"
    adb shell setprop "$BASE_PROP.opt_d" "$OPT_D"
    adb shell setprop "$BASE_PROP.opt_f" "$OPT_F"
    adb shell setprop "$BASE_PROP.opt_l" "$OPT_L"
    adb shell setprop "$BASE_PROP.opt_t" "$OPT_T"
    adb shell setprop "$BASE_PROP.opt_u" "$OPT_U"
    adb shell setprop "$BASE_PROP.opt_v" "$OPT_V"

    start_android_package
    info "Execute './${NAME} -k ${command}' to terminate the capture"
else
    #########
    # Linux #
    #########
    validate_executable $command

    # Create logs dir if option -d not used
    if [[ -z "$OPT_D" ]]; then
        OPT_D=$(mktemp -d)
        chmod 777 "$OPT_D"
    fi

    # Write meta data
    meta_dir="$OPT_D/meta"
    mkdir $meta_dir
    echo "$1" > "$meta_dir/app"
    echo "$@" > "$meta_dir/cmd"
    uname -r > "$meta_dir/kernel"
    uname -m > "$meta_dir/machine"
    sysctl net > "$meta_dir/net" 2>/dev/null
    uname -s > "$meta_dir/os"
    echo "$VERSION" > "$meta_dir/version"

    UNWANTED_ERRORS="wrong ELF class: ELFCLASS32|wrong ELF class: ELFCLASS64"

    ( \
    TCPSNITCH_OPT_B=$OPT_B \
    TCPSNITCH_OPT_C=$OPT_C \
    TCPSNITCH_OPT_D=$OPT_D \
    TCPSNITCH_OPT_F=$OPT_F \
    TCPSNITCH_OPT_L=$OPT_L \
    TCPSNITCH_OPT_T=$OPT_T \
    TCPSNITCH_OPT_U=$OPT_U \
    TCPSNITCH_OPT_V=$OPT_V \
    LD_PRELOAD="${I386_LIB} ${AMD64_LIB}" $@ 4>&1 2>&1 3>&2 1>/dev/null | \
    grep -E -v "$UNWANTED_ERRORS" \
    ) 3>&1 1>&2 2>&3

    # What just happened?
    # - Tcpsnitch opens 2 streams to file descriptors 3 and 4. These new 
    # streams serve as the new stdout/stderr for tcpsnitch. This allows us 
    # to distinguish stdout/stderr of tcpsnitch & of the traced process. 
    # - We swap stderr/stdout to filter out some errors on stderr.
    #
    # Basically:
    #       - 4>&1 2>&1: stderr of process and tcpsnitch go to stdout, they merge.
    #       - 3>&2: stdout of tcpsnitch goes to stderr.
    #       - 1>/devnull: discard stdout of process.
    #   - 3>&1 1>&2 2>&3: swap back stderr/stdout.

    info "Trace saved in $OPT_D"
fi
