#!/usr/bin/env bash
set -o nounset
# set -o xtrace

# Modify this to change name, version & libs path
readonly NAME="tcpsnitch"
readonly VERSION=0.1
readonly VERSION_STR="${NAME} version ${VERSION}"
readonly SERVER="ns328523.ip-37-187-114.eu"
readonly I386_LIB="lib${NAME}.so.${VERSION}-i386"
readonly AMD64_LIB="lib${NAME}.so.${VERSION}-x86_64"
readonly ARM_LIB="lib${NAME}.so.${VERSION}-arm"
readonly TOP_PID=$$
readonly SCRIPT_DIR=$(dirname "$(realpath "$0")")
readonly PROP_PREFIX="be.ucl.${NAME}"
readonly HIDDEN_ERRORS="wrong ELF class: ELFCLASS32|wrong ELF class: ELFCLASS64"

# Modify this this to change option default values
OPT_A=0
OPT_B=0
OPT_C=0
OPT_D="-" # Need non-empty value to fit OPTIONS_VALUES array
OPT_F=2
OPT_L=1
OPT_N=0
OPT_T=1000
OPT_U=0
OPT_V=0

OPTIONS_NAMES=(opt_a opt_b opt_c opt_d opt_f opt_l opt_n opt_t opt_u opt_v)
OPTIONS_COUNT=${#OPTIONS_NAMES[@]}

# Exit on TERM signal
trap "exit 1" TERM

error() {
    declare msg="$1"
    echo "${NAME}: ${msg}."
    echo "Try '${NAME} -h' for more information."
    kill -s TERM $TOP_PID
}

info() {
    echo "${1}."
}

usage() {
    echo "Usage: ${NAME} [-achv] [ -b <bytes> ] [ -d <dir>] [ -f <lvl> ]"
    echo "                 [ -k <pkg> ] [ -l <lvl> ] [ -t <msec> ]"
    echo "                 [ -u <usec> ] [ --version ] app <args>"
    echo ""
    echo "app         cmd/package to spy on."
    echo "<args>      args to cmd."
    echo "-a          instrument & launch app on connected android device."
    echo "-b <bytes>  dump tcp_info every <bytes> (0 means NO dump, def 0)."
    echo "-c          activate capture of pcap traces."
    echo "-d <dir>    dir to save traces (defaults to random dir in /tmp)."
    echo "-f <lvl>    verbosity of logs to file (0 to 5, defaults to 2)."
    echo "-h          show this help text."
    echo "-k <pkg>    kill instrumented android <pkg> and pull traces."
    echo "-l <lvl>    verbosity of logs to stderr (0 to 5, defaults to 2)."
    echo "-n          do (n)ot send traces to web server."
    echo "-t <msec>   dump to JSON file every <msec> (def. 1000)."
    echo "-u <usec>   dump tcp_info every <usec> (0 means NO dump, def 0)."
    echo "-v          activate verbose output."
    echo "--version   print ${NAME} version."
}

is_integer() {
    [[ "$1" =~ ^[0-9]+$ ]]
}

assert_int() {
    declare int="$1"
    declare error_msg="$2"
    if ! is_integer "$int"; then
        error "$error_msg"
    fi
}

validate_args_number() {
    if [[ $# -lt 1 ]]; then
        error "too few arguments"
    fi
}

get_android_package() {
    declare package_name="$1"

    if [[ $# -ne 1 ]]; then
        error "missing package argument"
    fi

    # Check that adb sees exactly 1 device
    if [ $(adb devices | wc -l) -ne 3 ]; then
        error "adb must see exactly 1 device"
    fi

    declare prefix="package:"
    declare match=$(adb shell pm list packages | grep -m 1 -s "${package_name}" | tr -d '\r')

    # Check that package exists
    if [ -z "${match}" ]; then
        error "invalid argument: package '${package_name}' not found"
    fi

    PACKAGE=${match#${prefix}}
    info "Found Android package: '${PACKAGE}'"
}

start_android_package() {
    adb shell "monkey -p ${PACKAGE} -c android.intent.category.LAUNCHER 1 >/dev/null"
    info "Start package '${PACKAGE}'"
}

kill_android_package() {
    adb shell su -c am force-stop "${PACKAGE}"
}

pull_trace_for_android_package() {
    declare tracesdir="/data/data/${PACKAGE}/${NAME}"

    if [[ ! $(adb shell su -c ls "${tracesdir}") ]]; then
        error "no traces for '${PACKAGE}'"
    fi

    info "Pulling trace from Android device..."

    declare tmpdir=$(mktemp -d)
    chmod 777 "$tmpdir"
    adb shell su -c ls "${tracesdir}" | while read -r line; do
        trace=$(echo "${line}" | tr -d '\r')
        adb shell su -c mv "${tracesdir}/${trace}" "/data/${trace}"
        adb shell su busybox chmod -R 777 "/data/${trace}"
        adb pull "/data/${trace}" "${tmpdir}/${trace}" 2>/dev/null
        adb shell su -c rm -rf "/data/${trace}"
    done

    info "Trace saved in ${tmpdir}"
}

zip_trace() {
    cd "${OPT_D}" || error "Could not cd to ${OPT_D}"
    tar -czf archive.tar.gz ./*
}

upload_trace() {
    if [[ $OPT_N -eq "1" ]]; then exit; fi

    while true; do
        read -p "Do you wish to upload this trace to ${SERVER}? (y/n): " yn
        case "${yn}" in
            [Yy]* ) break;;
            [Nn]* ) exit;;
            * ) echo "Please answer yes or no.";;
        esac
    done

    info "Uploading trace..."
    if ! curl --connect-timeout 2 --progress-bar -F "app_trace[archive]=@${OPT_D}/archive.tar.gz" "http://${SERVER}/app_traces"; then
        info "Failed to connect to ${SERVER}"
    fi
}

parse_options() {
    # Parse options
    while getopts ":achnpvb:d:f:k:l:u:t:-:" opt; do
        case "${opt}" in
            -) # Trick to parse long options with getopts.
                case "${OPTARG}" in
                    version)
                        info "${VERSION_STR}"
                        exit 0
                        ;;
                esac
                ;;
            a)
                OPT_A=1
                ;;
            b)
                assert_int "${OPTARG}" "invalid -b argument: '${OPTARG}'" 
                OPT_B=${OPTARG}
                ;;
            c)
                OPT_C=1;
                ;;
            d)
                if [[ ! -d "${OPTARG}" ]] ; then
                    error "invalid -d argument: '${OPTARG}'"
                fi
                OPT_D=${OPTARG}
                ;;
            f)
                assert_int "${OPTARG}" "invalid -f argument: '${OPTARG}'" 
                OPT_F=${OPTARG}
                ;;
            h)
                usage
                exit 0
                ;;
            k)
                get_android_package "${2}"
                kill_android_package
                pull_trace_for_android_package
                zip_trace
                upload_trace
                exit 0
                ;;
            l)
                assert_int "${OPTARG}" "invalid -l argument: '${OPTARG}'" 
                OPT_L=${OPTARG}
                ;;
            n)
                OPT_N=1
                ;;
            u)
                assert_int "${OPTARG}" "invalid -u argument: '${OPTARG}'" 
                OPT_U=${OPTARG}
                ;;
            t)
                assert_int "${OPTARG}" "invalid -t argument: '${OPTARG}'"
                OPT_T=${OPTARG}
                ;;
            v)
                OPT_V=$((OPT_V+1))
                ;;
            \?)
                error "invalid option"
                ;;
        esac
    done
}

###################
# Start of script #
###################

parse_options "$@"
OPTIONS_VALS=($OPT_A $OPT_B $OPT_C $OPT_D $OPT_F $OPT_L $OPT_N $OPT_T $OPT_U $OPT_V)

# Consume option args
shift $((OPTIND - 1))

validate_args_number "$@"

cmd="$1"

if [[ $OPT_A -eq "1" ]]; then
    ###########
    # Android #
    ###########
    # Test if Android lib is present
    cd "$SCRIPT_DIR" || exit "Could not cd to ${SCRIPT_DIR}"
    if [[ ! -f ${ARM_LIB} ]]; then
        error "${ARM_LIB} missing! Reinstall ${NAME} for Android (see README)"
    fi

    # Validate package
    get_android_package "$cmd"

    # Kill package if running
    kill_android_package

    # Desactivate Selinux
    adb shell su -c setenforce 0

    # Create logs dir
    OPT_D="/data/data/${PACKAGE}/${NAME}"
    adb shell su -c rm -rf "$OPT_D"
    adb shell su -c mkdir -m 777 -p "$OPT_D"

    # Write meta data
    meta_dir="$OPT_D/meta"
    adb shell mkdir "$meta_dir"
    adb shell "echo ${PACKAGE} > ${meta_dir}/app"
    adb shell "echo ${PACKAGE} > ${meta_dir}/cmd"
    adb shell "uname -r > ${meta_dir}/kernel"
    adb shell "uname -m > ${meta_dir}/machine"
    adb shell "sysctl net > ${meta_dir}/net 2>/dev/null"
    adb shell "echo android > ${meta_dir}/os"
    adb shell "echo ${VERSION} > ${meta_dir}/version"
    adb shell "echo ${PACKAGE} > ${meta_dir}/app"
    for i in $(seq 0 $((${OPTIONS_COUNT}-1))); do
        adb shell "echo ${OPTIONS_VALS[$i]} > ${meta_dir}/${OPTIONS_NAMES[$i]}"
    done

    # Upload lib
    LIBPATH="/data"
    adb shell su -c chmod 777 /data
    adb shell rm -f "${LIBPATH}/${ARM_LIB}"
    info "Uploading ${NAME} library to ${LIBPATH}/${ARM_LIB}"
    adb push ${ARM_LIB} ${LIBPATH} 2>/dev/null

    # Properties are limited to 32 chars includind the NULL byte.
    # With "wrap." being 5 chars, we have 26 chars left the app name.
    adb shell setprop wrap."${PACKAGE:0:26}" LD_PRELOAD="${LIBPATH}/${ARM_LIB}"
    adb shell setprop "${PROP_PREFIX}.opt_b" "$OPT_B"
    adb shell setprop "${PROP_PREFIX}.opt_c" "$OPT_C"
    adb shell setprop "${PROP_PREFIX}.opt_d" "$OPT_D"
    adb shell setprop "${PROP_PREFIX}.opt_f" "$OPT_F"
    adb shell setprop "${PROP_PREFIX}.opt_l" "$OPT_L"
    adb shell setprop "${PROP_PREFIX}.opt_t" "$OPT_T"
    adb shell setprop "${PROP_PREFIX}.opt_u" "$OPT_U"
    adb shell setprop "${PROP_PREFIX}.opt_v" "$OPT_V"

    start_android_package
    info "Execute './${NAME} -k ${cmd}' to terminate the capture"
else
    #########
    # Linux #
    #########
    # Validate cmd
    if [ -f "$cmd" ]; then
        # Resolve absolute path for $1 & update positional parameter accordingly
        cmd=$(realpath "$cmd")
        set -- "$cmd" "${@:2}"

        if ! [[ -x "$cmd" ]]; then
            error "invalid cmd: '$cmd' is not executable"
        fi
    else
        if ! which "$cmd" > /dev/null; then
            error "invalid argument: '$cmd' is not in \$PATH"
        fi
    fi

    # Test if libs are present
    cd "$SCRIPT_DIR" || error "Could not cd to ${SCRIPT_DIR}"
    if [[ ! -f ${I386_LIB} ]]; then
        error "${I386_LIB} missing! Reinstall ${NAME}"
    fi
    if [[ ! -f ${AMD64_LIB} ]]; then
        error "${AMD64_LIB} missing! Reinstall ${NAME}"
    fi

    # Create logs dir if option -d not used
    if [[ "-" == "$OPT_D" ]]; then
        OPT_D=$(mktemp -d)
        chmod 777 "$OPT_D"
    fi

    # Extract app (split on '/' and take last)
    # Global replace (//) in $1 of / (escaped) by ' ' & interpret as array
    array=(${1//\// });
    app=${array[-1]}

    # Write meta data
    meta_dir="$OPT_D/meta"
    mkdir "$meta_dir"
    echo "$app" > "${meta_dir}/app"
    echo "$@" > "${meta_dir}/cmd"
    uname -r > "${meta_dir}/kernel"
    uname -m > "${meta_dir}/machine"
    sysctl net > "${meta_dir}/net" 2>/dev/null
    uname -s > "${meta_dir}/os"
    echo "$VERSION" > "${meta_dir}/version"
    for i in $(seq 0 $((${OPTIONS_COUNT}-1))); do
        echo "${OPTIONS_VALS[$i]}" > ${meta_dir}/${OPTIONS_NAMES[$i]}
    done


    ( \
    TCPSNITCH_OPT_B=$OPT_B \
    TCPSNITCH_OPT_C=$OPT_C \
    TCPSNITCH_OPT_D=$OPT_D \
    TCPSNITCH_OPT_F=$OPT_F \
    TCPSNITCH_OPT_L=$OPT_L \
    TCPSNITCH_OPT_T=$OPT_T \
    TCPSNITCH_OPT_U=$OPT_U \
    TCPSNITCH_OPT_V=$OPT_V \
    LD_PRELOAD="./${I386_LIB} ./${AMD64_LIB}" "$@" 4>&1 3>&2 2>&1 1>/dev/null \
    | grep -E -v "wrong ELF class" \
    ) 3>&2 1>&2 2>&3

    # Note that tcpsnitch opens 2 streams to file descriptors 3 and 4. These new
    # streams serve as the new stdout/stderr for tcpsnitch. This allows us to 
    # distinguish stdout/stderr of tcpsnitch & of the traced process.

    info "Trace saved in ${OPT_D}"
    zip_trace
    upload_trace
fi

